<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 15: Forms & API Integration</title>
</head>
<body>
    <h1>Forms & API Integration</h1>
    <ul>
        <li>useEffect Hook: Learn when and why to use the useEffect hook.</li>
        <li>Fetching Data: Use useEffect to fetch data from APIs and manage loading states and errors.</li>
        <li>Forms: Create and validate both simple and complex forms, including custom controls like star ratings.</li>
        <li>Project Work: Build create and edit forms, and sunchronize your app with a backend API using conditional rendering for loading and error states.</li>
    </ul>

    <h2>UI: React Intro to State</h2>
    <p>Github Repo: https://github.com/natafaye/fesd-slides-clone</p>
    <p>Branch: git checkout react-intro-to-state</p>

    <h3>Front-End</h3>
    <p>State to Rendering to User to Listening to State</p>
    <ul>
        <li>When the app first loads in, React automatically renders based on the state</li>
        <li>We'll write listening even handlers that trigger when the user does something.</li>
        <li>We'll have our listening event handlers update the state</li>
        <li>React automatically re-renders the component when its state changes</li>
    </ul>

    <h3>React State</h3>
    <p>Data that changes - and when it changes, the component should rerender</p>

    <h4>Rules of State</h4>
    <ul>
        <li>1. State is data that changes, there's no reason to put unchanging data in state</li>
        <li>2. State must only be in one place, never duplicated</li>
        <li>3. State can only be shared with lower components, never higher or sibling components</li>
        <li>4. State is immutable, never change it directly</li>

    </ul>

    <h4>Rules of Array Destructuring</h4>
    <ul>
        <li>1. The order of the variables nees to match the order of the items</li>
        <li>2. The names don't matter</li>
        <li>3. You don't have to take all the items</li>
    </ul>

    <h4>Building with React</h4>
    <ul>
        <li>1. Break the app into components</li>
        <li>2. Pass the data down through props</li>
        <li>3. Decide what to put in state and where</li>
        <li>4. Update the state in event listeners</li>
    </ul>

    <h4>Creating a Normal Variable</h4>
    <p>let variable = INITIAL_VALUE</p>

    <h4>Creating a State Variable</h4>
    <p>const [state, setState] = useState(INITIAL_VALUE)</p>
    <ul>
        <li>Pick names for these (after const...state and setState) variables. The second one is a function</li>
        <li>Put a starting value here (INITIAL_VALUE), like 0 or null of "none" or true</li>
    </ul>

    <h4>Returned Array Destructuring (Pattern)</h4>
    <p>
        function functionName() {
            return someArray
        }

        const [variableName, variable2Name, etc] = functionName()
    </p>

    <p>
        example:

        function useState() {
            return someArray
        }

        cosnt [state, setState] = useState()
    </p>

    <h4>Updating a State Variable</h4>
    <p>
        setState(NEW_VALUE)
    </p>

    <ul>
        <li>Replace setState with the name you picked for your function variable</li>
        <li>Put a new value here (NEW_VALUE)</li>
    </ul>

    <h2>Operations: Optional Chaining</h2>
    <p>
        https://docs.google.com/presentation/d/1VVA103r5ii8MQCYC6VcyDZmis7y5A3SL2yypH5q7EY8/edit?usp=sharing
    </p>

    <h3>Optional Chaining</h3>
    <p>
        object?.property
    </p>
    <p>
        If the object is null or undefined, it won't try to get the propert, it'll just simplify to undefined
    </p>

    <h3>Sample Card Component</h3>
    <p>
        function ProductCard({ productId }: { productId: number }) {
            const product - products.find(p => p.id === productId)
            return <h3>{ product.name }</h3>
        }
    </p>
    <ul>
        <li>product in product.name is going to give a type error: ERROR product could be undefined</li>
        <li>We could use an if check before return: if(!product) return <h3></h3></li>
        <li>Or we could use *Optional Chaining*: product.name will change to product?.name;
            If product is undefined, it will simplify to undefined, and the h3 will be empty
        </li>
    </ul>

    <h3>Clarification:</h3>
    <P>Normal Chaining: object.property</P>
    <p>Optional Chaining: object?.property</p>

    <h3>Chaining Optional Chaining</h3>
    <p>
        object?.objectProperty?.property
    </p>
    <p>If the object is null or undefined, or if objectProperty is null or undefined, it'll just simplify to undefined
    </p>


    <h1>UI: React Lifting State Up</h1>
    <p>
        https://docs.google.com/presentation/d/1AflDCswiXqTBEv-HRCSrIgtTFs3xCOW2sVbGwJzBSB0/edit?usp=sharing
    </p>
    <p>
        Github Repo: https://github.com/natafaye/fesd-slides-clone
        Branch: git checkout react-lifting-state-up
    </p>

    <h2>Lifting State Up</h2>
    <p>
        Moving state higher in the component tree so that the state and state settter can be used by lower components
    </p>

    <h3>Communicate</h3>
    <p>
        <CartItemList cartList={cartList}/>
        <CartTotal cartList={cartList}/>
    </p>
    <p>
        We can use props to pass data down to another component 
    </p>

    <h3>Customize</h3>
    <p>
        <Button theme="success">Submit</Button>
        <Button1 theme="danger"></Button1>
    </p>
    <p>
        We can use props to allow a component to be reused in different ways and customized to each use
    </p>

    <h3>Rules of Props</h3>
    <ul>
        <li>1. Always destructure your props for readability</li>
        <li>2. Props can only be passed down, never across or up</li>
    </ul>

    <h2>UI: React Bootstrap</h2>
    <p>
        https://docs.google.com/presentation/d/1lEBkqK_ZnfGUtLT4l1a2brwwNx5kySwlA-NPgpjAbZ8/edit?usp=sharing
    </p>
    <p>
        Github Repo: https://github.com/natafaye/fesd-slides-clone
        Branch: git checkout react-bootstrap
    </p>

    <h3>React Bootstrap</h3>
    <p>
        A library that makes it more convenient to use Bootstrap in React
    </p>

    <h4>React: is declarative: The code says what to do</h4>
    <h4>Bootstrp: is imperative: The codes says how to do it</h4>

    <h3>React Bootstrap</h3>
    <p>A library that makes it more convenient to use Bootstrap in React</p>

    <h3>Concept of Component</h3>
    <p>A piece of the UI with its own appearance and functionality</p>

    <h4>Implementation of Bootstrap Component</h4>
    <p>A set of HTML snippets and CSS classes that can be used together</p>

    <h4>Implementation of React Component</h4>
    <p>A function that can take in props as input and returns JSX as output</p>

    <h4>Implementation of React Bootstrap Component</h4>
    <p>A react component that returns JSX for a Bootstrap component and hooks up Bootstrap's JavaScript</p>

    <h2>Simple Data</h2>
    <p>strings: const [color, setColor] = useState("green")</p>
    <p>setColor("purple")</p>
    <p>numbers: const [count, setCount] = useState(0)</p>
    <p>setCount(count +1)</p>
    <p>booleans: const [show, setShow] = useState(false)</p>
    <p>setShow(!show)</p>

    <h2>Complex Data</h2>
    <p>objects: const [user, setUser] = useState({ level: 3 })</p>
    <p>arrays: const [list, setList] = useState([])</p>

    <h3>Immutability</h3>
    <p>
        Remove from an Array:
        someArray = someArray.filter(
            item => item.id !== idToDelete
        )
    </p>
    <p>
        Add to an Array:
        someArray = [ ...someArray, newItem ]
    </p>
    <p>
        Update an Object:
        someObject = {
            ...someObject,
            property: newValue
        }
    </p>
    <p>
        Update an Object in an Array:
        someArray = someArray.map(item => (
            item.id !== idToUpdate ? item : {
                ...item,
                property: newValue
            }
        ))
    </p>

    <h3>Benefits of Immutability</h3>
    <ul>
        <li>Better for asynchronous programming: If multiple pieces of asynchronous code are using the same state at the same time, they'll never mess each other up, because each only changes copies of the state</li>
        <li>Fewer bugs: The state is less likely to be changed in an unexpected way. It's easier to test because you don't have to worry about another part of the code changing the state - they'd only make a changed copy</li>
        <li>Easier to maintain: When one part of the code is given the state, it knows that no other par to of the code will change that exact object or array - so that part of the code can be worked on independently from the other parts.</li>
    </ul>

    <h1>UI: React Complex State - Update</h1>
    <p>
        https://docs.google.com/presentation/d/1bok1dhEwKscK6wubn-rBNFTjEJRSzH-DNRtyZaIdyVo/edit?usp=sharing
    </p>
    <p>
        Github Repo: https://github.com/natafaye/fesd-slides-clone
        Branch: git checkout react-complex-state
    </p>

    <h1>Variables: More Typescript</h1>
    <p>
        https://docs.google.com/presentation/d/1bok1dhEwKscK6wubn-rBNFTjEJRSzH-DNRtyZaIdyVo/edit?usp=sharing
    </p>
    <p>
        Github Repo: https://github.com/natafaye/fesd-slides-clone
        Branch: git checkout more-typescript
    </p>

    <h2>Typescript: A version of JavaScript where each variable is given a type</h2>
    <h3>Import & Export Types</h3>
    <ul>
        <li>
            Export Type: export type User = { id: number, name: string }
        </li>
        <li>
            Import Type: import type { User } from "./types.ts"
        </li>
    </ul>

    <h2>Typing UseState</h2>
    <h3>Typing useState: const [state, setState] = useState("") or const [state, setState] = useState([])</h3>
    <p>
        Typing useState:
        const [state, setState] = useState<TYPE>(initialValue)
        
        You can set a type on your state like this (see <TYPE>)
    </p>
    <p>Example:
        Typing Array in useState:
        const [state, setState] = useState<string[]>([])

        const [state, setState] = useState<Array<string>>([])
    </p>
    <p>
        const [state, setState] = useState<NamedType[]>([])

        const [state, setState] = useState<Array<NamedType>>([])
    </p>

    <h2>Typing Union in useState</h2>
    <p>
        const [state, setState] = useState<string | null>(null)

        const [state, setState] = useState<number | string>("auto")
    </p>

    <h2>Typing Event Object</h2>
    <p>
        <!-- Typing Event Object: <button onClick={event => {}}></button> -->

        if the event handler is inline, the event object will be automatically typed
    </p>
    <p>
        <button type="button" onClick={handleEvent} title="Click to handle event">Click Me</button>

        const handleEvent = (event: TYPE) => {}

        But if the handler is separate, the event object will need to be manually typed
    </p>
    <p>
        Two most common types of events: Click and change
        const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {}

        const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {}
    </p>

    <h3>Event Types</h3>
    <ul>
        <li>React.MouseEvent<   ></li>
        <li>React.ChangeEvent<   ></li>
        <li>React.KeyBoardEvent<   ></li>
        <li>React.FocusEvent<   ></li>
        <li>React.FormEvent<   ></li>
        <li>React.DragEvent<   ></li>
        <li>React.ToucheEvent<   ></li>
        <li>React.WheelEvent<   ></li>
        <li>...and more!</li>
    </ul>

    <h3>HTML Element Types</h3>
    <ul>
        <li>HTMLButtonElement</li>
        <li>HTMLAnchorElement</li>
        <li>HTMLDivElement</li>
        <li>HTMLFormElement</li>
        <li>HTMLHEadingElement</li>
        <li>HTMLImageElement</li>
        <li>HTMLInputElement</li>
        <li>HTMLLiElement</li>
        <li>HTMLSelectElement</li>
        <li>HTMLTextAreaElement</li>
        <li>...and more!</li>
    </ul>

    <h2>Type Assertion</h2>
    <p>As Type Assertion: 
        document.getElementById("some-id") as HTMLInputElement
        response.json() as string[]
    </p>

    <h2>!Type Assertion</h2>
    <p>
        document.getElementById("some-id")!.textContent
        list.find(item => item.id === DEFAULT_ITEM)!.name
    </p>
    <h3>*CAUTION*</h3>
    <ul>
        <li>1. Only use type assertion if you need it</li>
        <li>Using type assertion is leaving the safety zone</li>
    </ul>

    <h2>Utility Types</h2>
    <p>
        Partial Type: Make a new type with all the properties Optional

        const update = (id: number, updatedProperties: Partial<Email>) => {}
    </p>

    <h3>Email</h3>
    <p>
        type Email = {
            id: number
            author: string
            text: string
        }

        this is a type of Email for your code
    </p>

    <h3>Partial<Email></h3>
        <p>
            {
            id?: number
            author?: string
            text?: string
        }

        Partial will set up the elements in email to be optional; this can be useful when your making an update function and you want to take in whatever properties need updating; you can update some of the properties if that's what is needed.
        </p>

    <h2>Required Type</h2>
    <p>Make a new type with all the properties Required

        const setAdmin = (newAdmin: Required<User>) => {}
    </p>

    <h3>User</h3>
    <p>
        type User = {
            id: number
            name: string
            phone: string
            email: string
            adminLevel?: number 
        }
    </p>

    <h3>Required<User></h3>
        <p>
            {
                id: number 
                number: string
                phone: string 
                email: string 
                adminlevel: number 
            }

            this will work only if the User had properties that were optional
        </p>

    <h2>Pick Type</h2>
    <p>
        Make a new type with only some properties included

        let contactInfo: Pick<User, "email" | "phone"> => {
            email: user.email,
            phone: user.phone
        }
    </p>

    <h3>User</h3>
    <p>
        type User = {
            id: number 
            name: string 
            phone: string 
            email: string 
            adminLevel?: number
        }
    </p>

    <h3>Pick<User, "email" | "phone"></h3>
    <p>
        {
            phone: string 
            email: string 
        }
    </p>

    <h3>Omit Type (Opposite Pick Type)</h3>
    <p>
        Make a new type with some properties excluded

        const update = (id: number, updatedEmail: Omit<Email, "id">) => {}

        The properties to omit (see "id in red above")
    </p>

    <p>for example:

        Email: 
        type Email = {
            id: number 
            author: string 
            text: string 
        }

        Omit<Email, "id">:
            {
                author: string 
                text: string 
            }
    </p>
</body>
</html>