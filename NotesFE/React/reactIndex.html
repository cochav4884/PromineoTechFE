<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction To React</title>
</head>
<body>
    <h1>React</h1>
    <h2>Principles of Functional Programming</h2>
    <ul>
        <li>Declarative Code</li>
        <li>Immutable State</li>
        <li>Pure Functions</li>
        <li>Type System</li>
    </ul>

    <p>React is a JavaScript library for building user interfaces. It allows developers to create reusable UI components and manage the state of those components efficiently.</p>
    <p>React is often used in conjunction with other libraries and frameworks, such as React Router for routing, Redux for state management, and various UI component libraries like Material-UI or Ant Design.</p> 
    <p>React is maintained by Facebook and has a large community of developers who contribute to its ecosystem.</p>
    <p>React is widely used in web development and has gained popularity for its performance, flexibility, and ease of use.</p>

    <h3>Declarative Code</h3>
    <p>Declarative code describes what the program should accomplish without specifying how to achieve it. In React, developers describe the UI they want to create, and React takes care of updating the DOM efficiently.</p>
    <p>Declarative code is easier to read and understand, making it a preferred approach in modern web development.</p> 
    <p>Declarative code allows developers to focus on the desired outcome rather than the implementation details, leading to cleaner and more maintainable code.</p>
    <p>Declarative code is often contrasted with imperative code, which specifies a sequence of steps to achieve a result.</p>
    <p>Declarative code is a key principle of functional programming, which emphasizes the use of pure functions and immutability.</p>
    <p>Declarative code is widely used in modern web frameworks and libraries, including React, Vue.js, and Angular.</p>
    <p>Declarative code is often easier to test and debug, as it focuses on the end result rather than the implementation details.</p>
    <p>Declarative code can lead to better performance, as it allows the underlying framework or library to optimize the rendering process.</p>

    <h3>Immutable State</h3>
    <p>Immutable state refers to the concept of not modifying the state directly. Instead, developers create new copies of the state with the desired changes.</p>
    <p>Immutable state helps prevent unintended side effects and makes it easier to reason about the state of the application.</p>
    <p>Immutable state is a key principle of functional programming, which emphasizes the use of pure functions and immutability.</p>
    <p>Immutable state is often used in conjunction with libraries like Immutable.js or Immer to manage complex state structures.</p>
    <p>Immutable state can lead to better performance, as it allows the underlying framework or library to optimize the rendering process.</p>
    <p>Immutable state is widely used in modern web frameworks and libraries, including React, Vue.js, and Angular.</p>
    <p>Immutable state is often easier to test and debug, as it prevents unintended side effects and makes it easier to reason about the state of the application.</p>

    <h3>Pure Functions</h3>
    <p>Pure functions are functions that always return the same output for the same input and do not have any side effects.</p>
    <p>Pure functions are easier to test and reason about, as they do not depend on external state or modify any state.</p>
    <p>Pure functions are a key principle of functional programming, which emphasizes the use of pure functions and immutability.</p>
    <p>Pure functions are often used in conjunction with libraries like Lodash or Ramda to create functional programming utilities.</p>
    <p>Pure functions can lead to better performance, as they allow the underlying framework or library to optimize the rendering process.</p>
    <p>Pure functions are widely used in modern web frameworks and libraries, including React, Vue.js, and Angular.</p>
    <p>Pure functions are often easier to test and debug, as they do not depend on external state or modify any state.</p>
    <p>Pure functions can be composed together to create more complex functions, leading to cleaner and more maintainable code.</p>
    <p>Pure functions can be memoized to improve performance, as they always return the same output for the same input.</p>
   
    <h3>Type System</h3>
    <p>A type system is a set of rules that defines how types are assigned to values and how those types can be used in a programming language.</p>
    <p>A type system helps catch errors at compile time rather than runtime, leading to more robust and maintainable code.</p>  
    <p>A type system can be static or dynamic, with static type systems checking types at compile time and dynamic type systems checking types at runtime.</p>
    <p>A type system can be strong or weak, with strong type systems enforcing strict type rules and weak type systems allowing more flexibility in type usage.</p>
    <p>A type system can be structural or nominal, with structural type systems checking types based on their structure and nominal type systems checking types based on their names.</p>
    <p>A type system can be inferred or explicit, with inferred type systems automatically determining types based on usage and explicit type systems requiring developers to specify types.</p>
    <p>A type system can be optional or mandatory, with optional type systems allowing developers to choose whether to use types and mandatory type systems requiring types for all values.</p>
    <p>A type system can be gradual or static, with gradual type systems allowing developers to mix typed and untyped code and static type systems requiring all code to be typed.</p>
    <p>A type system can be expressive or limited, with expressive type systems allowing for complex type definitions and limited type systems providing a simpler set of types.</p>
    <p>A type system can be extensible or fixed, with extensible type systems allowing developers to create custom types and fixed type systems providing a predefined set of types.</p>
    <p>A type system can be generic or specific, with generic type systems allowing for type parameters and specific type systems providing concrete types.</p>
    <p>A type system can be polymorphic or monomorphic, with polymorphic type systems allowing for multiple types and monomorphic type systems providing a single type.</p>

    <h2>React Components</h2>
    <p>React components are the building blocks of a React application. They can be functional or class-based, and they manage their own state and props.</p>
    <p>Components can be composed together to create complex UIs, and they can be reused across different parts of the application.</p>
    <p>Components can be stateless or stateful, with stateless components being simpler and easier to test.</p>
    <p>Components can be controlled or uncontrolled, with controlled components managing their own state and uncontrolled components relying on external state management.</p>
    <p>Components can be functional or class-based, with functional components being simpler and easier to test.</p>
    <p>Components can be presentational or container, with presentational components focusing on rendering UI and container components managing state and logic.</p>
    <p>Components can be higher-order or regular, with higher-order components being functions that take a component and return a new component.</p>
    <p>Components can be pure or impure, with pure components being functions that always return the same output for the same input.</p>
    <p>Components can be synchronous or asynchronous, with synchronous components rendering immediately and asynchronous components rendering after a delay.</p>
    <p>Components can be functional or class-based, with functional components being simpler and easier to test.</p>
    <p>Components can be stateless or stateful, with stateless components being simpler and easier to test.</p>
    <p>Components can be controlled or uncontrolled, with controlled components managing their own state and uncontrolled components relying on external state management.</p>
    <p>Components can be presentational or container, with presentational components focusing on rendering UI and container components managing state and logic.</p>

    <h3>Component</h3>
    <p>A piece of the UI with its own appearance and functionality</p>

    <h3>Building with React</h3>
    <ul>
        <li>Break the app into components</li>
    </ul>
</body>
</html>