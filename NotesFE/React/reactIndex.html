<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction To React</title>
</head>
<body>
    <h1>React</h1>
    <h2>Principles of Functional Programming</h2>
    <ul>
        <li>Declarative Code</li>
        <li>Immutable State</li>
        <li>Pure Functions</li>
        <li>Type System</li>
    </ul>

    <p>React is a JavaScript library for building user interfaces. It allows developers to create reusable UI components and manage the state of those components efficiently.</p>
    <p>React is often used in conjunction with other libraries and frameworks, such as React Router for routing, Redux for state management, and various UI component libraries like Material-UI or Ant Design.</p> 
    <p>React is maintained by Facebook and has a large community of developers who contribute to its ecosystem.</p>
    <p>React is widely used in web development and has gained popularity for its performance, flexibility, and ease of use.</p>

    <h3>Declarative Code</h3>
    <p>Declarative code describes what the program should accomplish without specifying how to achieve it. In React, developers describe the UI they want to create, and React takes care of updating the DOM efficiently.</p>
    <p>Declarative code is easier to read and understand, making it a preferred approach in modern web development.</p> 
    <p>Declarative code allows developers to focus on the desired outcome rather than the implementation details, leading to cleaner and more maintainable code.</p>
    <p>Declarative code is often contrasted with imperative code, which specifies a sequence of steps to achieve a result.</p>
    <p>Declarative code is a key principle of functional programming, which emphasizes the use of pure functions and immutability.</p>
    <p>Declarative code is widely used in modern web frameworks and libraries, including React, Vue.js, and Angular.</p>
    <p>Declarative code is often easier to test and debug, as it focuses on the end result rather than the implementation details.</p>
    <p>Declarative code can lead to better performance, as it allows the underlying framework or library to optimize the rendering process.</p>

    <h3>Immutable State</h3>
    <p>Immutable state refers to the concept of not modifying the state directly. Instead, developers create new copies of the state with the desired changes.</p>
    <p>Immutable state helps prevent unintended side effects and makes it easier to reason about the state of the application.</p>
    <p>Immutable state is a key principle of functional programming, which emphasizes the use of pure functions and immutability.</p>
    <p>Immutable state is often used in conjunction with libraries like Immutable.js or Immer to manage complex state structures.</p>
    <p>Immutable state can lead to better performance, as it allows the underlying framework or library to optimize the rendering process.</p>
    <p>Immutable state is widely used in modern web frameworks and libraries, including React, Vue.js, and Angular.</p>
    <p>Immutable state is often easier to test and debug, as it prevents unintended side effects and makes it easier to reason about the state of the application.</p>

    <h3>Pure Functions</h3>
    <p>Pure functions are functions that always return the same output for the same input and do not have any side effects.</p>
    <p>Pure functions are easier to test and reason about, as they do not depend on external state or modify any state.</p>
    <p>Pure functions are a key principle of functional programming, which emphasizes the use of pure functions and immutability.</p>
    <p>Pure functions are often used in conjunction with libraries like Lodash or Ramda to create functional programming utilities.</p>
    <p>Pure functions can lead to better performance, as they allow the underlying framework or library to optimize the rendering process.</p>
    <p>Pure functions are widely used in modern web frameworks and libraries, including React, Vue.js, and Angular.</p>
    <p>Pure functions are often easier to test and debug, as they do not depend on external state or modify any state.</p>
    <p>Pure functions can be composed together to create more complex functions, leading to cleaner and more maintainable code.</p>
    <p>Pure functions can be memoized to improve performance, as they always return the same output for the same input.</p>
   
    <h3>Type System</h3>
    <p>A type system is a set of rules that defines how types are assigned to values and how those types can be used in a programming language.</p>
    <p>A type system helps catch errors at compile time rather than runtime, leading to more robust and maintainable code.</p>  
    <p>A type system can be static or dynamic, with static type systems checking types at compile time and dynamic type systems checking types at runtime.</p>
    <p>A type system can be strong or weak, with strong type systems enforcing strict type rules and weak type systems allowing more flexibility in type usage.</p>
    <p>A type system can be structural or nominal, with structural type systems checking types based on their structure and nominal type systems checking types based on their names.</p>
    <p>A type system can be inferred or explicit, with inferred type systems automatically determining types based on usage and explicit type systems requiring developers to specify types.</p>
    <p>A type system can be optional or mandatory, with optional type systems allowing developers to choose whether to use types and mandatory type systems requiring types for all values.</p>
    <p>A type system can be gradual or static, with gradual type systems allowing developers to mix typed and untyped code and static type systems requiring all code to be typed.</p>
    <p>A type system can be expressive or limited, with expressive type systems allowing for complex type definitions and limited type systems providing a simpler set of types.</p>
    <p>A type system can be extensible or fixed, with extensible type systems allowing developers to create custom types and fixed type systems providing a predefined set of types.</p>
    <p>A type system can be generic or specific, with generic type systems allowing for type parameters and specific type systems providing concrete types.</p>
    <p>A type system can be polymorphic or monomorphic, with polymorphic type systems allowing for multiple types and monomorphic type systems providing a single type.</p>

    <h2>React Components</h2>
    <p>An often pure, mostly declarative function that can take in props as input and returns JSX as output.</p>
    <p>React components are the building blocks of a React application. They can be functional or class-based, and they manage their own state and props.</p>
    <p>Components can be composed together to create complex UIs, and they can be reused across different parts of the application.</p>
    <p>Components can be stateless or stateful, with stateless components being simpler and easier to test.</p>
    <p>Components can be controlled or uncontrolled, with controlled components managing their own state and uncontrolled components relying on external state management.</p>
    <p>Components can be functional or class-based, with functional components being simpler and easier to test.</p>
    <p>Components can be presentational or container, with presentational components focusing on rendering UI and container components managing state and logic.</p>
    <p>Components can be higher-order or regular, with higher-order components being functions that take a component and return a new component.</p>
    <p>Components can be pure or impure, with pure components being functions that always return the same output for the same input.</p>
    <p>Components can be synchronous or asynchronous, with synchronous components rendering immediately and asynchronous components rendering after a delay.</p>
    <p>Components can be functional or class-based, with functional components being simpler and easier to test.</p>
    <p>Components can be stateless or stateful, with stateless components being simpler and easier to test.</p>
    <p>Components can be controlled or uncontrolled, with controlled components managing their own state and uncontrolled components relying on external state management.</p>
    <p>Components can be presentational or container, with presentational components focusing on rendering UI and container components managing state and logic.</p>

    <h3>Component</h3>
    <p>A piece of the UI with its own appearance and functionality</p>

    <h3>Building with React</h3>
    <ul>
        <li>Break the app into components</li>
    </ul>

    <h3>Rules of Components</h3>
    <ul>
        <li>
            1. The function name must start with a capital letter
            <ul>
                <li>correct: function MyComponentName() {}</li>
                <li>incorrect: function myComponentName() {}</li>
            </ul>
        </li>
        <li>
            2. The component must be used like it's an HTML element
            <ul>
                <li>correct: &lt;MyComponentName/&gt;</li>
                <li>incorrect: MyComponentName()</li>
            </ul>
        </li>
        <li>
            3. The function must return one top-level element
            <ul>
                <li>correct: return &lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ol&gt;</li>
                <li>incorrect: return &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;</li>
            </ul>
        </li>
    </ul>

    <h3>JSX</h3>
    <p>JSX is a syntax extension for JavaScript that allows developers to write HTML-like code within JavaScript files. It is commonly used in React to describe the structure of the UI.</p>
    <p>JSX is not required to use React, but it is widely adopted due to its readability and ease of use.</p>
    <p>JSX is transpiled to JavaScript using tools like Babel, allowing developers to write cleaner and more maintainable code.</p>
    <p>JSX allows developers to embed JavaScript expressions within HTML-like code, making it easier to create dynamic UIs.</p>
    <p>JSX allows developers to create components using a familiar syntax, making it easier to understand and work with React.</p>
    <p>JSX allows developers to create reusable components that can be composed together to create complex UIs.</p>
    <p>JSX allows developers to use HTML-like syntax to describe the structure of the UI, making it easier to read and understand.</p>
    <p>JSX allows developers to use JavaScript expressions within HTML-like code, making it easier to create dynamic UIs.</p>

    <h3>Using Components inside another Component</h3>
    <p>Components can be nested within other components to create a hierarchy of UI elements. This allows for better organization and reusability of code.</p>
    <p>Components can pass data to their child components using props, allowing for a unidirectional data flow.</p> 
    <p>Components can communicate with each other using callbacks or context, allowing for more complex interactions between components.</p>
    <p>Components can be composed together to create complex UIs, and they can be reused across different parts of the application.</p>
    
    <h3>Example of a Component Inside Another Component:</h3>
    <p>In this example, the <code>App</code> component renders the <code>Header</code> and <code>Footer</code> components, creating a simple layout for the application.</p>
    <p>```javascript</p>
    <p>import React from 'react';</p>
    <p>import Header from './Header';</p>
    <p>import Footer from './Footer';</p>
    <p>const App = () => {</p>
    <p>  return (</p>
    <p>    <div className="app-container"> </p>
    <p>      <Header title="My App" /> </p>
    <p>      <main className="app-content"> </p>
    <p>        <h1>Welcome to My App</h1> </p>
    <p>        <p>This is a simple example of a React component.</p> </p>
    <p>      </main> </p>
    <p>      <Footer /> </p>
    <p>    </div> </p>
    <p>  ); </p>
    <p>}; </p>
    <p>export default App;</p>
    <p>```</p>


    <p>In this example, the <code>Header</code> and <code>Footer</code> components are imported and used within the <code>App</code> component. The <code>Header</code> component receives a prop called <code>title</code>, which is used to display the title of the application.</p>
    <p>The <code>App</code> component also includes a <code>main</code> section where the main content of the application is displayed.</p>
    <p>The <code>Footer</code> component is rendered at the bottom of the application, providing a consistent layout.</p>
    <p>This example demonstrates how components can be composed together to create a complete application layout.</p>
    <p>Components can be reused across different parts of the application, allowing for better organization and maintainability of code.</p>
    <p>Components can also be styled using CSS or CSS-in-JS libraries, allowing for a consistent look and feel across the application.</p>
    <p>Components can be tested using tools like Jest or React Testing Library, allowing for better code quality and reliability.</p>
    <p>Components can be documented using tools like Storybook or Styleguidist, allowing for better collaboration and communication within the development team.</p>
    <p>Components can be optimized using techniques like code splitting or lazy loading, allowing for better performance and user experience.</p>
    <p>Components can be deployed using tools like Netlify or Vercel, allowing for easy hosting and deployment of React applications.</p>
    <p>Components can be versioned using tools like Git or GitHub, allowing for better collaboration and version control within the development team.</p>
    <p>Components can be maintained using tools like ESLint or Prettier, allowing for better code quality and consistency.</p>
    <p>Components can be shared using tools like npm or Yarn, allowing for better collaboration and code reuse within the development community.</p>
    <p>Components can be published using tools like npm or GitHub Packages, allowing for better distribution and sharing of React components.</p>
    <p>Components can be contributed to using tools like GitHub or Bitbucket, allowing for better collaboration and community involvement in the development of React components.</p>

    <h3>Component Renders</h3>
    <p>When a component is rendered, React creates a virtual representation of the component in memory. This virtual DOM is then compared to the actual DOM, and only the necessary changes are made to update the UI.</p>
    <p>This process is known as reconciliation, and it allows React to efficiently update the UI without having to re-render the entire component tree.</p>
    <p>React uses a diffing algorithm to compare the virtual DOM with the actual DOM, allowing it to determine the minimal set of changes needed to update the UI.</p>
    <p>React also uses a concept called "keys" to help identify which elements have changed, been added, or removed from the component tree. This allows React to optimize the rendering process and improve performance.</p>
    <p>React components can also implement lifecycle methods, which are special methods that are called at different points in the component's lifecycle. These methods allow developers to perform actions like fetching data, updating state, or cleaning up resources.</p>
    <p>React components can also use hooks, which are special functions that allow developers to manage state and side effects in functional components. Hooks provide a more concise and readable way to manage component state and lifecycle events.</p>
    <p>React components can also use context, which is a way to share data between components without having to pass props down through the component tree. Context allows for better organization and management of global state in React applications.</p>
    <p>React components can also use refs, which are a way to access and interact with DOM elements directly. Refs allow for better control over the component's behavior and can be used for tasks like focusing an input field or measuring the size of an element.</p>
    <p>React components can also use prop types, which are a way to validate the props passed to a component. Prop types help catch errors and improve the reliability of the component.</p>
    <p>React components can also use default props, which are a way to provide default values for props that are not passed to the component. Default props help ensure that the component behaves as expected even when certain props are not provided.</p>
    <p>React components can also use error boundaries, which are a way to catch and handle errors that occur during rendering. Error boundaries help improve the reliability of the application and provide a better user experience.</p>
    <p>React components can also use portals, which are a way to render a component outside of its parent component's DOM hierarchy. Portals allow for better organization and management of the component tree.</p>


    <h2>UI: React JSX</h2>
    <p>JSX: A markup language that looks like HTML, but is written in JavaScript.</p>
    <p>JSX is a syntax extension for JavaScript that allows developers to write HTML-like code within JavaScript files. It is commonly used in React to describe the structure of the UI.</p>
    <p>JSX is not required to use React, but it is widely adopted due to its readability and ease of use.</p>
    <p>JSX is transpiled to JavaScript using tools like Babel, allowing developers to write cleaner and more maintainable code.</p>
    <p>JSX allows developers to embed JavaScript expressions within HTML-like code, making it easier to create dynamic UIs.</p>
    <p>JSX allows developers to create components using a familiar syntax, making it easier to understand and work with React.</p>
    <p>JSX allows developers to create reusable components that can be composed together to create complex UIs.</p>

    There are a few diffrences between HTML and JSX:
    <ul>
        <li>1. className instead of class</li>
        <li>2. htmlFor instead of for</li>
        <li>3. camelCase for attributes (e.g., onClick instead of onclick)</li>
        <li>4. JSX expressions must be wrapped in parentheses if they span multiple lines</li>
        <li>5. JSX requires a single parent element</li>
        <li>6. JSX allows for embedding JavaScript expressions within curly braces</li>
        <li>7. JSX allows for self-closing tags</li>
        <li>8. JSX allows for comments using curly braces (e.g., {/* comment */})</li>
        <li>9. JSX allows for fragments using <React.Fragment> or shorthand syntax <> </></li>
        <li>10. JSX allows for conditional rendering using ternary operators or logical && operator</li>
        <li>11. JSX allows for mapping over arrays to create lists of elements</li>
    </ul>

    Exmaples:

    <P>Imperative vs Declarative</P>
    <p>See react.js for examples!</p>

    <h2>React Props</h2>
    <p>Set like they're HTML attributes, recieved as an object parameter</p>
    <h3>Communicate</h3>

    <P>
        <CartItemList cartList={cartList} />
        <CartTotal cartList={cartList} />
    </P>
    <p>We can use props to pass data down to another component</p>

    <h3>Cutomize</h3>
    <p>
        <Button theme="success" type="button" title="Success Button">Green Success Button</Button>
        <Button theme="danger" type="button" title="Danger Button">Red Danger Button</Button>
    </p>
    <p>We can use props to allow a component to be reused in different ways and customized to each use</p>

    <p>Example:</p>

    <ul>
        <li>In the parent component, you write:
            <Panel title="border" open="{false}"/>
        </li>
        <li>In the background, React runs:
            Panel({title: "border", open: false})
            *IMPORTANT!: You don't write this! Never call a component function directly, let React do that.*
        </li>
        <li>In the child component, you write:
            funtion Panel({title, open}) {

            }
        </li>
    </ul>

    <p>Rule for Props</p>
    <p>1. Always destructure your props for readability
        <br>
        correct: function Card({ text, style }) {
            return <div className={style}>{text}</div>
        }
        <br>
        incorrect: function Card(props) {
            return <div className={props.style}>{props.text}</div>
        }
    </p>
    <p>2. Props can only be passed down, never across or up
        <br>
        correct: Parent
            (down to child)
            Child    Child

        <br>
        incorrect:         Parent
            Child (across to other child) Child
        
        <br>
        incorrect:   Parent
                 (up to parent)
                Child     Child
    </p>

    <p>In React, components don't know where they will be used, and they may be used in many places. <br>
    *They don't know their parent component and can't communicate with it*</p>

    <p>*But don't worry! There is a way to get data to flow up! We'll get there. *</p>

    <p>For Example:
        <br>
        <ul>
            <li>App: can send information down to props SearchBar</li>
            <li>props SearchBar: can send information down to props SpecialButton</li>
            <li>props SpecialButton: is at the bottom and does not send information up</li>
        </ul>
        <br>
        <ul>
            <li><h4>App: Sends down to:</h4></li>
            <li>props Toolbar</li>
            <li>props SlideView</li>
            <li>props Sidebar</li>
            <li><h4>props Toolbar: Sends down to:</h4></li>
            <li>props ToolbarButton</li>
            <li>props ToolbarButton</li>
            <li><h4>props SlideView: has no child to send to</h4></li>
            <li><h4>props Sidebar: Sends down to:</h4></li>
            <li>props SlideThumbnail</li>
            <li>props SlideThumbnail</li>
        </ul>
        
    </p>

    <h1>Building with React</h1>
    <ul>
        <li>Break the app into components</li>
        <li>Pass data down through props</li>
        <li>Decide what to put in state and where</li>
        <li>Update the state in event listeners</li>
    </ul>

    <h1>Install React Developer Tools</h1>

    <ul>
        <li>For Chrome:
            https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en 
        </li>
        <li>For Firefox:
            https://addons.mozilla.org/en-US/firefox/addon/react-devtools/ 
        </li>
        <li>For Edge:
            https://microsoftedge.microsoft.com/addons/detail/react-developer-tools/gpphkfbcpidddadnkolkpfckpihlkkil 
        </li>
        <li>Other browsers:
            see speaker notes
        </li>
    </ul>


</body>
</html>