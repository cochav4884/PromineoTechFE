<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction To React</title>
</head>
<body>
    <h1>React</h1>
    <h2>Principles of Functional Programming</h2>
    <ul>
        <li>Declarative Code</li>
        <li>Immutable State</li>
        <li>Pure Functions</li>
        <li>Type System</li>
    </ul>

    <p>React is a JavaScript library for building user interfaces. It allows developers to create reusable UI components and manage the state of those components efficiently.</p>
    <p>React is often used in conjunction with other libraries and frameworks, such as React Router for routing, Redux for state management, and various UI component libraries like Material-UI or Ant Design.</p> 
    <p>React is maintained by Facebook and has a large community of developers who contribute to its ecosystem.</p>
    <p>React is widely used in web development and has gained popularity for its performance, flexibility, and ease of use.</p>

    <h3>Declarative Code</h3>
    <p>Declarative code describes what the program should accomplish without specifying how to achieve it. In React, developers describe the UI they want to create, and React takes care of updating the DOM efficiently.</p>
    <p>Declarative code is easier to read and understand, making it a preferred approach in modern web development.</p> 
    <p>Declarative code allows developers to focus on the desired outcome rather than the implementation details, leading to cleaner and more maintainable code.</p>
    <p>Declarative code is often contrasted with imperative code, which specifies a sequence of steps to achieve a result.</p>
    <p>Declarative code is a key principle of functional programming, which emphasizes the use of pure functions and immutability.</p>
    <p>Declarative code is widely used in modern web frameworks and libraries, including React, Vue.js, and Angular.</p>
    <p>Declarative code is often easier to test and debug, as it focuses on the end result rather than the implementation details.</p>
    <p>Declarative code can lead to better performance, as it allows the underlying framework or library to optimize the rendering process.</p>

    <h3>Immutable State</h3>
    <p>Immutable state refers to the concept of not modifying the state directly. Instead, developers create new copies of the state with the desired changes.</p>
    <p>Immutable state helps prevent unintended side effects and makes it easier to reason about the state of the application.</p>
    <p>Immutable state is a key principle of functional programming, which emphasizes the use of pure functions and immutability.</p>
    <p>Immutable state is often used in conjunction with libraries like Immutable.js or Immer to manage complex state structures.</p>
    <p>Immutable state can lead to better performance, as it allows the underlying framework or library to optimize the rendering process.</p>
    <p>Immutable state is widely used in modern web frameworks and libraries, including React, Vue.js, and Angular.</p>
    <p>Immutable state is often easier to test and debug, as it prevents unintended side effects and makes it easier to reason about the state of the application.</p>

    <h3>Pure Functions</h3>
    <p>Pure functions are functions that always return the same output for the same input and do not have any side effects.</p>
    <p>Pure functions are easier to test and reason about, as they do not depend on external state or modify any state.</p>
    <p>Pure functions are a key principle of functional programming, which emphasizes the use of pure functions and immutability.</p>
    <p>Pure functions are often used in conjunction with libraries like Lodash or Ramda to create functional programming utilities.</p>
    <p>Pure functions can lead to better performance, as they allow the underlying framework or library to optimize the rendering process.</p>
    <p>Pure functions are widely used in modern web frameworks and libraries, including React, Vue.js, and Angular.</p>
    <p>Pure functions are often easier to test and debug, as they do not depend on external state or modify any state.</p>
    <p>Pure functions can be composed together to create more complex functions, leading to cleaner and more maintainable code.</p>
    <p>Pure functions can be memoized to improve performance, as they always return the same output for the same input.</p>
   
    <h3>Type System</h3>
    <p>A type system is a set of rules that defines how types are assigned to values and how those types can be used in a programming language.</p>
    <p>A type system helps catch errors at compile time rather than runtime, leading to more robust and maintainable code.</p>  
    <p>A type system can be static or dynamic, with static type systems checking types at compile time and dynamic type systems checking types at runtime.</p>
    <p>A type system can be strong or weak, with strong type systems enforcing strict type rules and weak type systems allowing more flexibility in type usage.</p>
    <p>A type system can be structural or nominal, with structural type systems checking types based on their structure and nominal type systems checking types based on their names.</p>
    <p>A type system can be inferred or explicit, with inferred type systems automatically determining types based on usage and explicit type systems requiring developers to specify types.</p>
    <p>A type system can be optional or mandatory, with optional type systems allowing developers to choose whether to use types and mandatory type systems requiring types for all values.</p>
    <p>A type system can be gradual or static, with gradual type systems allowing developers to mix typed and untyped code and static type systems requiring all code to be typed.</p>
    <p>A type system can be expressive or limited, with expressive type systems allowing for complex type definitions and limited type systems providing a simpler set of types.</p>
    <p>A type system can be extensible or fixed, with extensible type systems allowing developers to create custom types and fixed type systems providing a predefined set of types.</p>
    <p>A type system can be generic or specific, with generic type systems allowing for type parameters and specific type systems providing concrete types.</p>
    <p>A type system can be polymorphic or monomorphic, with polymorphic type systems allowing for multiple types and monomorphic type systems providing a single type.</p>

    <h2>React Components</h2>
    <p>An often pure, mostly declarative function that can take in props as input and returns JSX as output.</p>
    <p>React components are the building blocks of a React application. They can be functional or class-based, and they manage their own state and props.</p>
    <p>Components can be composed together to create complex UIs, and they can be reused across different parts of the application.</p>
    <p>Components can be stateless or stateful, with stateless components being simpler and easier to test.</p>
    <p>Components can be controlled or uncontrolled, with controlled components managing their own state and uncontrolled components relying on external state management.</p>
    <p>Components can be functional or class-based, with functional components being simpler and easier to test.</p>
    <p>Components can be presentational or container, with presentational components focusing on rendering UI and container components managing state and logic.</p>
    <p>Components can be higher-order or regular, with higher-order components being functions that take a component and return a new component.</p>
    <p>Components can be pure or impure, with pure components being functions that always return the same output for the same input.</p>
    <p>Components can be synchronous or asynchronous, with synchronous components rendering immediately and asynchronous components rendering after a delay.</p>
    <p>Components can be functional or class-based, with functional components being simpler and easier to test.</p>
    <p>Components can be stateless or stateful, with stateless components being simpler and easier to test.</p>
    <p>Components can be controlled or uncontrolled, with controlled components managing their own state and uncontrolled components relying on external state management.</p>
    <p>Components can be presentational or container, with presentational components focusing on rendering UI and container components managing state and logic.</p>

    <h3>Component</h3>
    <p>A piece of the UI with its own appearance and functionality</p>

    <h3>Building with React</h3>
    <ul>
        <li>Break the app into components</li>
    </ul>

    <h3>Rules of Components</h3>
    <ul>
        <li>1. The function name miust start with a capital letter 
            <p>correct: function MyComponentName() {}</p>
            <p>incorrect: function myComponentName() {}</p>
        </li>
        <li>2. The component must be used like it's an HTML element
            <p>correct: <MyComponentName/></p>
            <p>incorrect: MyComponentName()</p>
        </li>
    </ul>

    <h3>JSX</h3>
    <p>JSX is a syntax extension for JavaScript that allows developers to write HTML-like code within JavaScript files. It is commonly used in React to describe the structure of the UI.</p>
    <p>JSX is not required to use React, but it is widely adopted due to its readability and ease of use.</p>
    <p>JSX is transpiled to JavaScript using tools like Babel, allowing developers to write cleaner and more maintainable code.</p>
    <p>JSX allows developers to embed JavaScript expressions within HTML-like code, making it easier to create dynamic UIs.</p>
    <p>JSX allows developers to create components using a familiar syntax, making it easier to understand and work with React.</p>
    <p>JSX allows developers to create reusable components that can be composed together to create complex UIs.</p>
    <p>JSX allows developers to use HTML-like syntax to describe the structure of the UI, making it easier to read and understand.</p>
    <p>JSX allows developers to use JavaScript expressions within HTML-like code, making it easier to create dynamic UIs.</p>

    <h3>Using Components inside another Component</h3>
    <p>Components can be nested within other components to create a hierarchy of UI elements. This allows for better organization and reusability of code.</p>
    <p>Components can pass data to their child components using props, allowing for a unidirectional data flow.</p> 
    <p>Components can communicate with each other using callbacks or context, allowing for more complex interactions between components.</p>
    <p>Components can be composed together to create complex UIs, and they can be reused across different parts of the application.</p>
    
    <h3>Example of a Component Inside Another Component:</h3>
    <p>In this example, the <code>App</code> component renders the <code>Header</code> and <code>Footer</code> components, creating a simple layout for the application.</p>
    <p>```javascript</p>
    <p>import React from 'react';</p>
    <p>import Header from './Header';</p>
    <p>import Footer from './Footer';</p>
    <p>const App = () => {</p>
    <p>  return (</p>
    <p>    <div className="app-container"> </p>
    <p>      <Header title="My App" /> </p>
    <p>      <main className="app-content"> </p>
    <p>        <h1>Welcome to My App</h1> </p>
    <p>        <p>This is a simple example of a React component.</p> </p>
    <p>      </main> </p>
    <p>      <Footer /> </p>
    <p>    </div> </p>
    <p>  ); </p>
    <p>}; </p>
    <p>export default App;</p>
    <p>```</p>


    <p>In this example, the <code>Header</code> and <code>Footer</code> components are imported and used within the <code>App</code> component. The <code>Header</code> component receives a prop called <code>title</code>, which is used to display the title of the application.</p>
    <p>The <code>App</code> component also includes a <code>main</code> section where the main content of the application is displayed.</p>
    <p>The <code>Footer</code> component is rendered at the bottom of the application, providing a consistent layout.</p>
    <p>This example demonstrates how components can be composed together to create a complete application layout.</p>
    <p>Components can be reused across different parts of the application, allowing for better organization and maintainability of code.</p>
    <p>Components can also be styled using CSS or CSS-in-JS libraries, allowing for a consistent look and feel across the application.</p>
    <p>Components can be tested using tools like Jest or React Testing Library, allowing for better code quality and reliability.</p>
    <p>Components can be documented using tools like Storybook or Styleguidist, allowing for better collaboration and communication within the development team.</p>
    <p>Components can be optimized using techniques like code splitting or lazy loading, allowing for better performance and user experience.</p>
    <p>Components can be deployed using tools like Netlify or Vercel, allowing for easy hosting and deployment of React applications.</p>
    <p>Components can be versioned using tools like Git or GitHub, allowing for better collaboration and version control within the development team.</p>
    <p>Components can be maintained using tools like ESLint or Prettier, allowing for better code quality and consistency.</p>
    <p>Components can be shared using tools like npm or Yarn, allowing for better collaboration and code reuse within the development community.</p>
    <p>Components can be published using tools like npm or GitHub Packages, allowing for better distribution and sharing of React components.</p>
    <p>Components can be contributed to using tools like GitHub or Bitbucket, allowing for better collaboration and community involvement in the development of React components.</p>

    
</body>
</html>